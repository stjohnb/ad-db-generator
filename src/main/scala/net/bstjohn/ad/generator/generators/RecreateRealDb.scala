package net.bstjohn.ad.generator.generators

import net.bstjohn.ad.generator.format.ace.{Ace, RightName}
import net.bstjohn.ad.generator.format.groups.{Group, GroupMember}
import net.bstjohn.ad.generator.generators.entities.ComputerGenerator.{generateComputer, generateComputers}
import net.bstjohn.ad.generator.generators.entities.DomainGenerator.generateDomain
import net.bstjohn.ad.generator.generators.entities.GroupGenerator.{DomainAdminsGroupName, generateGroup}
import net.bstjohn.ad.generator.generators.entities.UserGenerator.{generateUser, generateUsers}
import net.bstjohn.ad.generator.generators.model.EpochSeconds
import net.bstjohn.ad.generator.snapshots.{DatabaseEvolution, DbSnapshot}

import java.util.{Calendar, GregorianCalendar, UUID}
import scala.annotation.unused
import scala.util.Random
import scala.util.Random.shuffle

object RecreateRealDb {

  def evolution(name: String, randomness: Int): DatabaseEvolution = {
    def random(range: Range): Range = Range(range.start * randomness, range.end * randomness)
    val date = new GregorianCalendar(2005, Calendar.FEBRUARY, 11).getTime
    val start = EpochSeconds.fromDate(date)
    val (domainAdminsGroup, s0) = init(start, name)
    val domain = s0.domain


    val computers = generateComputers(random(5 to 10), domain, start, start.plusYears(2))
    val attacker = generateUser(domain, start.plusHours(1), description = Some("attacker"))
    val s1 = s0.updated(
      _.withUpdatedUser(attacker.loggedOn(start.plusHours(1)))
        .withNewComputers(computers)
        .timestamp(start.plusHours(2)))

    val groupManagers = generateGroup(domain, s1.timestamp.plusMinutes(5), "Group managers",
      members = List(GroupMember.fromUser(attacker)))
    val managementComputer = generateComputer(domain, s1.timestamp.plusMinutes(5))
      .withAces(Seq(
        Ace(groupManagers.ObjectIdentifier, RightName.GenericAll),
        Ace(groupManagers.ObjectIdentifier, RightName.Owns)))
    val s2 = s1.updated(
      _.withUpdatedGroup(groupManagers)
        .withNewComputer(managementComputer)
        .timestamp(s1.timestamp.plusMinutes(10)))


    val csAgentsGroup = generateGroup(domain, s2.timestamp.plusMinutes(5), "CS Agents")
      .withGroupMember(attacker)
    val csAgentsComputer = generateComputer(domain, s2.timestamp.plusMinutes(5)).withAce(Ace(csAgentsGroup.ObjectIdentifier, RightName.GenericAll))
    val s3 = s2.updated(
      _.withUpdatedGroup(csAgentsGroup)
        .withNewComputer(csAgentsComputer)
        .timestamp(s2.timestamp.plusMinutes(5)))

    val s4 = addUsers(
      csAgentsGroup,
      random(5 to 10),
      s3,
      s3.timestamp.plusMonths(1),
      s3.timestamp.plusYears(1),
      Some("csAgent"))

    val s5 = addAdminUser(s4, domainAdminsGroup)

    val s6Start = s5.timestamp.plusYears(1)
    val domainAdminManagers =
      generateGroup(domain, s6Start, "Domain admin managers")
        .withAces(Ace(groupManagers.ObjectIdentifier, RightName.AddSelf))
        .withGroupMembers(shuffle(s5.users).take(3))
    val s6 = s5.updated(_
      .withUpdatedGroup(domainAdminManagers)
      .withUpdatedGroup(domainAdminsGroup.withAces(Ace(domainAdminManagers.ObjectIdentifier, RightName.GenericAll)))
      .timestamp(s6Start.plusDays(10)))

    val s7 = s6.updated(
      _.withUpdatedGroup(domainAdminManagers.withGroupMember(attacker))
        .withUpdatedGroup(domainAdminsGroup.withGroupMember(attacker))
        .withLateralMovementIds(Seq(attacker.ObjectIdentifier))
        .timestamp(s6.timestamp.plusMonths(2)))

    val s8 = (1 to 10).foldRight(s7.updated(_.clearLateralMovementIds))((i, evolution) => {
      if(i % 2 == 0) {
        newGroupAndUsers(evolution, random)
      } else {
        newGroupExistingUsers(evolution, random)
      }
    })

    s8
  }

  private def init(start: EpochSeconds, name: String): (Group, DatabaseEvolution) = {
    val domain = generateDomain(start)
    val domainAdminsGroup = generateGroup(domain, start, name = DomainAdminsGroupName)

    (domainAdminsGroup, DatabaseEvolution(
      name,
      DbSnapshot(
        domain.withDomainAdminsGroup(domainAdminsGroup),
        List.empty,
        List(domainAdminsGroup),
        List.empty,
        start,
        Seq.empty)))
  }

  @unused
  private def newGroupAndUsers(evolution: DatabaseEvolution, random: Range => Range) = {
    val start = evolution.timestamp.plusMinutes(5)
    val end = evolution.timestamp.plusMonths(1)

    val newUsers = generateUsers(random(0 to 20), evolution.domain, start, end)
    val newGroup = generateGroup(evolution.domain, start, s"Autogenerated group ${UUID.randomUUID()}")
      .withGroupMembers(newUsers)

    val newComputers = generateComputers(random(1 to 10), evolution.domain, start, end)
      .map(_.withAce(Ace(newGroup.ObjectIdentifier, RightName.GenericAll)))

    evolution.updated(
      _.withUpdatedGroup(newGroup)
        .withNewComputers(newComputers)
        .withUpdatedUsers(newUsers)
        .timestamp(evolution.timestamp.plusMonths(1)))
  }


  @unused
  private def newGroupExistingUsers(evolution: DatabaseEvolution, random: Range => Range) = {
    val start = evolution.timestamp.plusMinutes(5)
    val end = evolution.timestamp.plusMonths(1)

    val newGroup = generateGroup(evolution.domain, start, s"Autogenerated group ${UUID.randomUUID()}")
      .withGroupMembers(evolution.users.filter(_ => Random.nextBoolean() && Random.nextBoolean()))

    val newComputers = generateComputers(random(1 to 10), evolution.domain, start, end)
      .map(_.withAce(Ace(newGroup.ObjectIdentifier, RightName.GenericAll)))

    evolution.updated(
      _.withUpdatedGroup(newGroup)
        .withNewComputers(newComputers)
        .timestamp(evolution.timestamp.plusMonths(1)))
  }

  private def addUsers(
    group: Group,
    usersCount: Range,
    evolution: DatabaseEvolution,
    start: EpochSeconds,
    end: EpochSeconds,
    description: Option[String]
  ): DatabaseEvolution = {
    val users = generateUsers(usersCount, evolution.domain, start, end, description)

    evolution.updated(
      _.withUpdatedUsers(users)
      .withUpdatedGroup(group.withGroupMembers(users))
      .timestamp(end))
  }

  private def addAdminUser(
    evolution: DatabaseEvolution,
    domainAdminsGroup: Group
  ): DatabaseEvolution = {
    val newAdmin = generateUser(
      evolution.domain,
      evolution.timestamp.plusMonths(1),
      description = Some("new-admin"))

    evolution.updated(
      _.withUpdatedGroup(domainAdminsGroup.withGroupMember(newAdmin))
        .withUpdatedUser(newAdmin)
        .timestamp(evolution.timestamp.plusMonths(2)))
  }
}
