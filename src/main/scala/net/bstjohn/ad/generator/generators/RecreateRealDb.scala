package net.bstjohn.ad.generator.generators

import net.bstjohn.ad.generator.format.ace.{Ace, RightName}
import net.bstjohn.ad.generator.format.groups.{Group, GroupMember}
import net.bstjohn.ad.generator.generators.entities.ComputerGenerator.{generateComputer, generateComputers}
import net.bstjohn.ad.generator.generators.entities.DomainGenerator.generateDomain
import net.bstjohn.ad.generator.generators.entities.GroupGenerator.{DomainAdminsGroupName, generateGroup}
import net.bstjohn.ad.generator.generators.entities.UserGenerator.{generateUser, generateUsers}
import net.bstjohn.ad.generator.generators.model.EpochSeconds
import net.bstjohn.ad.generator.snapshots.{DatabaseEvolution, DbSnapshot}

import java.util.{Calendar, GregorianCalendar, UUID}
import scala.annotation.unused
import scala.util.Random
import scala.util.Random.shuffle

object RecreateRealDb {

  def evolution(name: String, randomness: Int): DatabaseEvolution = {
    def scaled(range: Range): Range = Range(range.start * randomness, range.end * randomness)
    def sample(range: Range): Int = Random.nextInt(range.end - range.start) + range.start

    val date = new GregorianCalendar(2005, Calendar.FEBRUARY, 11).getTime
    val start = EpochSeconds.fromDate(date)
    val (domainAdminsGroup, s0) = init(start, name)
    val domain = s0.domain

    val s1End = start.plusMonths(2)
    val attacker = generateUser(domain, start.plusHours(1), description = Some("attacker"))
    val s1 = s0.updated(
      _.withUpdatedUser(attacker.loggedOn(s1End))
        .withNewComputers(generateComputers(scaled(1 to 10), domain, start, s1End))
        .withUpdatedUsers(generateUsers(scaled(1 to 10), domain, start, s1End).map(_.loggedOn(s1End)))
        .timestamp(s1End))

    val groupManagers = generateGroup(domain, s1.timestamp.plusMinutes(5), "Group managers",
      members = List(GroupMember.fromUser(attacker))
    ).withGroupMembers(Random.shuffle(s1.users).take(sample(scaled(1 to 2))))
    val managementComputer = generateComputer(domain, s1.timestamp.plusMinutes(5))
      .withAces(Seq(
        Ace(groupManagers.ObjectIdentifier, RightName.GenericAll),
        Ace(groupManagers.ObjectIdentifier, RightName.Owns)))
    val s2 = s1.updated(
      _.withUpdatedGroup(groupManagers)
        .withNewComputer(managementComputer)
        .timestamp(s1.timestamp.plusMinutes(10)))

    val usersGroup = generateGroup(domain, s2.timestamp.plusMonths(1))
      .withGroupMember(attacker)
    val s3 = s2.updated(
      _.withUpdatedGroup(usersGroup)
        .withNewComputers(
          generateComputers(scaled(5 to 10), domain, s2.timestamp, s2.timestamp.plusMonths(1))
            .map(_.ownedBy(usersGroup)))
        .timestamp(s2.timestamp.plusMonths(1)))

    val s4 = addUsers(
      usersGroup,
      scaled(5 to 10),
      s3,
      s3.timestamp.plusMonths(1),
      s3.timestamp.plusYears(1))

    val s5 = addAdminUser(s4, domainAdminsGroup)

    val s6Start = s5.timestamp.plusYears(1)
    val domainAdminManagers =
      generateGroup(domain, s6Start, "Domain admin managers")
        .withAces(Ace(groupManagers.ObjectIdentifier, RightName.AddSelf))
        .withGroupMembers(shuffle(s5.users).take(3))
    val s6 = s5.updated(_
      .withUpdatedGroup(domainAdminManagers)
      .withUpdatedGroup(domainAdminsGroup.withAces(Ace(domainAdminManagers.ObjectIdentifier, RightName.GenericAll)))
      .timestamp(s6Start.plusDays(10)))

    val s7 = s6.updated(
      _.withUpdatedGroup(domainAdminManagers.withGroupMember(attacker))
        .withUpdatedGroup(domainAdminsGroup.withGroupMember(attacker))
        .withLateralMovementIds(Seq(attacker.ObjectIdentifier))
        .timestamp(s6.timestamp.plusMonths(2)))

    val s8 = (1 to 10).foldRight(s7.updated(_.clearLateralMovementIds))((i, evolution) => {
      if(i % 2 == 0) {
        newGroupAndUsers(evolution, scaled)
      } else {
        newGroupExistingUsers(evolution, scaled)
      }
    })

    s8
  }

  private def init(start: EpochSeconds, name: String): (Group, DatabaseEvolution) = {
    val domain = generateDomain(start)
    val user = generateUser(domain, start)
    val domainAdminsGroup = generateGroup(domain, start, name = DomainAdminsGroupName)
      .withGroupMember(user)

    (domainAdminsGroup, DatabaseEvolution(
      name,
      DbSnapshot(
        domain.withDomainAdminsGroup(domainAdminsGroup),
        List(user),
        List(domainAdminsGroup),
        List.empty,
        start,
        Seq.empty)))
  }

  @unused
  private def newGroupAndUsers(evolution: DatabaseEvolution, random: Range => Range) = {
    val start = evolution.timestamp.plusMinutes(5)
    val end = evolution.timestamp.plusMonths(1)

    val newUsers = generateUsers(random(1 to 20), evolution.domain, start, end)
    val newGroup = generateGroup(evolution.domain, start, s"Autogenerated group ${UUID.randomUUID()}")
      .withGroupMembers(newUsers)

    val newComputers = generateComputers(random(1 to 10), evolution.domain, start, end)
      .map(_.withAce(Ace(newGroup.ObjectIdentifier, RightName.GenericAll)))

    evolution.updated(
      _.withUpdatedGroup(newGroup)
        .withNewComputers(newComputers)
        .withUpdatedUsers(newUsers)
        .timestamp(evolution.timestamp.plusMonths(1)))
  }

  @unused
  private def newGroupExistingUsers(evolution: DatabaseEvolution, random: Range => Range) = {
    val start = evolution.timestamp.plusMinutes(5)
    val end = evolution.timestamp.plusMonths(1)

    val newGroup = generateGroup(evolution.domain, start, s"Autogenerated group ${UUID.randomUUID()}")
      .withGroupMembers(evolution.users.filter(_ => Random.nextBoolean() && Random.nextBoolean()))

    val newComputers = generateComputers(random(1 to 10), evolution.domain, start, end)
      .map(_.withAce(Ace(newGroup.ObjectIdentifier, RightName.GenericAll)))

    evolution.updated(
      _.withUpdatedGroup(newGroup)
        .withNewComputers(newComputers)
        .timestamp(evolution.timestamp.plusMonths(1)))
  }

  private def addUsers(
    group: Group,
    usersCount: Range,
    evolution: DatabaseEvolution,
    start: EpochSeconds,
    end: EpochSeconds,
    description: Option[String] = None
  ): DatabaseEvolution = {
    val users = generateUsers(usersCount, evolution.domain, start, end, description)

    evolution.updated(
      _.withUpdatedUsers(users)
      .withUpdatedGroup(group.withGroupMembers(users))
      .timestamp(end))
  }

  private def addAdminUser(
    evolution: DatabaseEvolution,
    domainAdminsGroup: Group
  ): DatabaseEvolution = {
    val newAdmin = generateUser(
      evolution.domain,
      evolution.timestamp.plusMonths(1),
      description = Some("new-admin"))

    evolution.updated(
      _.withUpdatedGroup(domainAdminsGroup.withGroupMember(newAdmin))
        .withUpdatedUser(newAdmin)
        .timestamp(evolution.timestamp.plusMonths(1)))
  }
}
